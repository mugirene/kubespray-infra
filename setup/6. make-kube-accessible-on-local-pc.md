# Kubernetes External API Access with Token Authentication for `username`

## **Overview**

This guide explains how to create a service account for a user, generate a token, bind appropriate permissions, and configure kubeconfig for external access. It also covers multi-cluster setups.

---

## **Step 1: Create Service Account**

Create a service account for `username` in the `kube-system` namespace:

```bash
kubectl create serviceaccount username -n kube-system
```

✅ Confirms the creation of the service account.

---

## **Step 2: Bind Permissions**

For cluster-wide access, bind the service account to the `cluster-admin` role:

```bash
kubectl create clusterrolebinding username-binding \
  --clusterrole=cluster-admin \
  --serviceaccount=kube-system:username
```

> ⚠️ In production, consider defining a **restricted ClusterRole** instead of `cluster-admin`.

---

## **Step 3: Obtain Token**

### For Kubernetes v1.24+:

```bash
kubectl -n kube-system create token username
```

### For Kubernetes < v1.24:

```bash
SECRET_NAME=$(kubectl -n kube-system get sa username -o jsonpath="{.secrets[0].name}")
kubectl -n kube-system get secret $SECRET_NAME -o jsonpath="{.data.token}" | base64 --decode
```

> Save the token securely — it will be used in the kubeconfig.

---

## **Step 4: Create Kubeconfig**

You need a token to log in. Since we already decided your main user is aimemalaika, generate a token for it:
```yaml
kubectl -n kube-system create token aimemalaika
```

Create a file `username-kubeconfig.yaml`:

```yaml
apiVersion: v1
kind: Config
clusters:
- cluster:
    server: https://<API_SERVER_IP>:6443
    certificate-authority: /etc/kubernetes/pki/ca.crt
  name: kubernetes
users:
- name: username
  user:
    token: <PASTE_YOUR_TOKEN_HERE>
contexts:
- name: username-context
  context:
    cluster: kubernetes
    user: username
current-context: username-context
```

✅ This allows `kubectl` or other clients to authenticate using the token.

---

## **Step 5: Test Kubeconfig**

```bash
export KUBECONFIG=./username-kubeconfig.yaml
kubectl get pods --all-namespaces
```

* Should list all pods if the service account has sufficient permissions.
* If you see authentication errors, double-check the token and API server address.

---

## **Step 6: Multi-Cluster Setup**

If you have multiple clusters, each with its own API server:

### Option 1: Single Merged Kubeconfig

```yaml
clusters:
- name: cluster-1
  cluster:
    server: https://api.cluster1.example.com:6443
    certificate-authority: /path/to/ca1.crt
- name: cluster-2
  cluster:
    server: https://api.cluster2.example.com:6443
    certificate-authority: /path/to/ca2.crt

users:
- name: username-cluster1
  user:
    token: <TOKEN_FOR_CLUSTER1>
- name: username-cluster2
  user:
    token: <TOKEN_FOR_CLUSTER2>

contexts:
- name: context-cluster1
  context:
    cluster: cluster-1
    user: username-cluster1
- name: context-cluster2
  context:
    cluster: cluster-2
    user: username-cluster2

current-context: context-cluster1
```

Switch clusters with:

```bash
kubectl config use-context context-cluster2
```

### Option 2: Separate Kubeconfig Files

* Keep one kubeconfig per cluster and switch by exporting `KUBECONFIG`:

```bash
export KUBECONFIG=./kubeconfig-cluster1.yaml
kubectl get pods

export KUBECONFIG=./kubeconfig-cluster2.yaml
kubectl get pods
```

* Or merge them using:

```bash
KUBECONFIG=./kubeconfig-cluster1.yaml:./kubeconfig-cluster2.yaml \
kubectl config view --merge --flatten > merged-kubeconfig.yaml
export KUBECONFIG=./merged-kubeconfig.yaml
```

---

## **Step 7: Security Recommendations**

1. **Restrict permissions** using ClusterRoles instead of full `cluster-admin` if possible.
2. **Use a VPN or private network** for external API access.
3. **Rotate tokens regularly**.
4. **Enable audit logging** to track API access.
5. **Use HTTPS and valid CA certificates** for secure communication.
